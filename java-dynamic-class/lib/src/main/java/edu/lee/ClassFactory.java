/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.lee;

import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.Map;

public class ClassFactory {
//    public static Object createClassObject(String className, String source) throws Exception {
//        // 通过 ToolProvider 取得 JavaCompiler 对象，JavaCompiler 对象是动态编译工具的主要对象
//        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
//
//        // 通过 JavaCompiler 取得标准 StandardJavaFileManager 对象，StandardJavaFileManager 对象主要负责
//        // 编译文件对象的创建，编译的参数等等，我们只对它做些基本设置比如编译 CLASSPATH 等。
//        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
//
//        // 因为是从内存中读取 Java 源文件，所以需要创建我们的自己的 JavaFileObject，即 InMemoryJavaFileObject
//        JavaFileObject fileObject = new InMemoryJavaFileObject(className, source);
//        Iterable<? extends JavaFileObject> files = Arrays.asList(fileObject);
//
//        // 编译结果信息的记录
//        StringWriter sw = new StringWriter();
//
//        // 编译目的地设置
//        Iterable options = Arrays.asList("-d", "c:/tmp");
//
//        // 通过 JavaCompiler 对象取得编译 Task
//        JavaCompiler.CompilationTask task = compiler.getTask(sw, fileManager, null, options, null, files);
//
//        // 调用 call 命令执行编译，如果不成功输出错误信息
//        if (!task.call()) {
//            String failedMsg = sw.toString();
//            System.err.println("Build Error:" + failedMsg);
//            return null;
//        }
//
//        Class cls = Class.forName(className);
//
//        return cls.getDeclaredConstructor().newInstance();
//    }

    public static Object createClassObject(String className, String source) throws Exception {
        Map<String, byte[]> results;
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager stdManager = compiler.getStandardFileManager(null, null, null);
        try (MemoryJavaFileManager manager = new MemoryJavaFileManager(stdManager)) {
            JavaFileObject javaFileObject = manager.makeStringSource(className, source);
            JavaCompiler.CompilationTask task = compiler.getTask(null, manager, null, null, null, Arrays.asList(javaFileObject));
            if (task.call()) {
                System.out.println("compile success");
                results = manager.getClassBytes();
            }else{
                System.err.println("compile failed");
                return null;
            }
        }

        MemoryClassLoader loader = new MemoryClassLoader(results);
        return loader.findClass(className).getDeclaredConstructor().newInstance();
    }
}
